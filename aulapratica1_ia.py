# -*- coding: utf-8 -*-
"""AulaPratica1_IA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yRRudqCqymM_hE5CYQYSw0pjMk9EX2Ei

seu nome ou da sua dupla

Primeiro modelo GAN de IA. É utilizado para aprendizado de máquina para gerar novos dados semelhantes a um conjunto de dados de treinamento.
"""

#importando as bibliotecas que vou usar
import tensorflow as tf
from tensorflow.keras import layers

#função para criar o gerador
def build_generator(latent_dim, output_shape):
  model = tf.keras.Sequential()
  model.add(layers.Dense(256, input_dim=latent_dim, activation='relu'))
  model.add(layers.BatchNormalization())
  model.add(layers.Dense(512, activation='relu'))
  model.add(layers.BatchNormalization())
  model.add(layers.Dense(1024, activation='relu'))
  model.add(layers.BatchNormalization())
  model.add(layers.Dense(output_shape, activation='tanh'))
  return model

#função para criar o discriminador
def build_discriminator(input_shape):
  model = tf.keras.Sequential()
  model.add(layers.Dense(1024, input_shape=(input_shape,), activation='relu'))
  model.add(layers.Dropout(0.3))
  model.add(layers.Dense(512, activation='relu'))
  model.add(layers.Dropout(0.3))
  model.add(layers.Dense(256, activation='relu'))
  model.add(layers.Dropout(0.3))
  model.add(layers.Dense(1, activation='sigmoid'))
  return model

#função modelo gan
def build_gan(generator, discriminator):
  discriminator.trainable = False
  model = tf.keras.Sequential()
  model.add(generator)
  model.add(discriminator)
  return model

#dimenções
latent_dim = 100
output_shape = 784

#criando as instâncias
generator = build_generator(latent_dim, output_shape)
discriminator = build_discriminator(output_shape)
gan = build_gan(generator, discriminator)

#compilações
generator.compile(loss='binary_crossentropy', optimizer='adam')
discriminator.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
gan.compile(loss='binary_crossentropy', optimizer='adam')

x=generator(input())

"""Este código uma vez treinado pode gerar novos dados que parecem pertercer ao mesmo conjunto de dados que foi usado para treinamento, como imagens que se assemelham a digitos manuscritos (por exemplo, MNIST)."""

#importando as bibliotecas que vou usar
import tensorflow as tf
from tensorflow.keras import layers
import numpy as np
import matplotlib.pyplot as plt

#função para criar o gerador
def build_generator(latent_dim, output_shape):
    model = tf.keras.Sequential()
    model.add(layers.Dense(256, input_dim=latent_dim, activation='relu'))
    model.add(layers.BatchNormalization())
    model.add(layers.Dense(512, activation='relu'))
    model.add(layers.BatchNormalization())
    model.add(layers.Dense(1024, activation='relu'))
    model.add(layers.BatchNormalization())
    model.add(layers.Dense(output_shape, activation='tanh'))
    return model

#função para criar o discriminador
def build_discriminator(input_shape):
    model = tf.keras.Sequential()
    model.add(layers.Dense(1024, input_shape=(input_shape,), activation='relu'))
    model.add(layers.Dropout(0.3))
    model.add(layers.Dense(512, activation='relu'))
    model.add(layers.Dropout(0.3))
    model.add(layers.Dense(256, activation='relu'))
    model.add(layers.Dropout(0.3))
    model.add(layers.Dense(1, activation='sigmoid'))
    return model

#função modelo gan
def build_gan(generator, discriminator):
    discriminator.trainable = False
    model = tf.keras.Sequential()
    model.add(generator)
    model.add(discriminator)
    return model

#dimensões
latent_dim = 100
output_shape = 784

#criando as instâncias
generator = build_generator(latent_dim, output_shape)
discriminator = build_discriminator(output_shape)
gan = build_gan(generator, discriminator)

#compilações
generator.compile(loss='binary_crossentropy', optimizer='adam')
discriminator.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
gan.compile(loss='binary_crossentropy', optimizer='adam')
##########################################################################################
# Gerando uma imagem
random_latent_vectors = np.random.normal(0, 1, (1, latent_dim))
generated_image = generator.predict(random_latent_vectors)

# Redimensionando a imagem para 28x28 (no caso de estar utilizando MNIST)
generated_image = generated_image.reshape(28, 28)

# Exibindo a imagem gerada
plt.imshow(generated_image, cmap='gray')
plt.title("Imagem Gerada pelo Gerador")
plt.show()

"""#outro"""

#importando as bibliotecas que vou usar
import tensorflow as tf
from tensorflow.keras import layers
import numpy as np
import matplotlib.pyplot as plt

#função para criar o gerador
def build_generator(latent_dim, output_shape):
    model = tf.keras.Sequential()
    model.add(layers.Dense(256, input_dim=latent_dim, activation='relu'))
    model.add(layers.BatchNormalization())
    model.add(layers.Dense(512, activation='relu'))
    model.add(layers.BatchNormalization())
    model.add(layers.Dense(1024, activation='relu'))
    model.add(layers.BatchNormalization())
    model.add(layers.Dense(output_shape, activation='tanh'))
    return model

#função para criar o discriminador
def build_discriminator(input_shape):
    model = tf.keras.Sequential()
    model.add(layers.Dense(1024, input_shape=(input_shape,), activation='relu'))
    model.add(layers.Dropout(0.3))
    model.add(layers.Dense(512, activation='relu'))
    model.add(layers.Dropout(0.3))
    model.add(layers.Dense(256, activation='relu'))
    model.add(layers.Dropout(0.3))
    model.add(layers.Dense(1, activation='sigmoid'))
    return model

#função modelo gan
def build_gan(generator, discriminator):
    discriminator.trainable = False
    model = tf.keras.Sequential()
    model.add(generator)
    model.add(discriminator)
    return model

#dimensões
latent_dim = 100
output_shape = 28 * 28  # Imagem 28x28, como no EMNIST

#criando as instâncias
generator = build_generator(latent_dim, output_shape)
discriminator = build_discriminator(output_shape)
gan = build_gan(generator, discriminator)

#compilações
generator.compile(loss='binary_crossentropy', optimizer='adam')
discriminator.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
gan.compile(loss='binary_crossentropy', optimizer='adam')

# Gerando uma imagem de uma letra
random_latent_vectors = np.random.normal(0, 1, (1, latent_dim))
generated_image = generator.predict(random_latent_vectors)

# Redimensionando a imagem para 28x28 pixels
generated_image = generated_image.reshape(28, 28)

# Exibindo a imagem gerada
plt.imshow(generated_image, cmap='gray')
plt.title("Imagem Gerada de uma Letra")
plt.show()